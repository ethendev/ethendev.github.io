---
layout: post
title:  JVM运行时内存区域
categories: [Java]
tags:  [JVM, 运行时, 内存]
keywords: JVM,运行时,内存
---

* content
{:toc}


java虚拟机在执行java程序的过程中，会把自己所管理的内存划分为几个不同的区域。每个区域的作用不同，创建和销毁的时间也不同。java虚拟机所管理的内存分为以下几个运行时区域：




![图片描述](http://image.codes51.com/Article/image/20151229/20151229083826_7418.jpg)

### 方法区
方法区（Method Area）是被所有线程共享区域，用于存放已被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。（对应JVM内存配置中的-PermSize等）。

方法区中包含运行时常量池（Runtime Constant Pool）。Class文件中除了类的版本、字段、方法、接口等描述信息外，还包含常量池，用于存放编译器生成的符号引用等，这部分内容将在类加载后存放在运行时常量池中。java语言并不要求常量一定只有编译器才能产生，运行期间也可能将新的常量放入池中。常量池在无法申请到内存是会抛出OutOfMemoryError异常。
   
### java堆
堆也是被所有线程共享的一块区域，在虚拟机启动时创建。java堆的唯一目的就是存放对象实例，几乎所有的对象实例都在java堆中分配内存。同时也包括数组。java堆是垃圾收集器管理的主要区域，因此，有的时候  也被称为GC堆（对应JVM内存配置中的-Xms和-Xmx等）。如果堆中没有内存完成实例分配，并且也无法扩展内存时，将抛出抛出OutOfMemoryError异常。
   
### java虚拟机栈
线程私有，它的生命周期同线程相同。每个方法执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。一个Java方法从调用到执行完的过程，就对应着一个栈帧从虚拟机栈入栈到出栈的过程（对应JVM内存配置中的-Xss）。

在java虚拟机规范中，对这个区域规定了2中异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

### 本地方法栈
本地方法栈类似与虚拟机栈，它们不同之处在于，虚拟机栈是为虚拟机执行的Java方法服务，而本地方法栈是为虚拟机使用到的Native方法服务；当JVM线程调用了本地方法， 则会跳入本地方法栈。本地方法返回后可能再次跳回java方法栈。

与虚拟机栈一样，本地方法栈会抛出StackOverflowError、OutOfMemoryError异常。

### 程序计数器
每个线程拥有自己独立的程序计数器，它指向正在执行的虚拟机字节码指令地址。当线程调用本地方法的时候， 它为undefined。此内存区域是唯一一个没有OutOfMemeryError情况的区域。