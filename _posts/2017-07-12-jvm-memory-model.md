---
layout: post
title:  Java内存模型
categories: [Java, JVM]
tags:  [Java, 内存, 模型]
keywords: Java,内存,模型
---


&emsp;&emsp;Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样底层细节。此处的变量与Java编程时所说的变量不一样，指包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，后者是线程私有的，不会被共享。




## 主内存与工作内存

&emsp;&emsp;Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存（可以与前面将的处理器的高速缓存类比），线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成。 

这里的主内存、工作内存与Java内存区域的Java堆、栈、方法区不是同一层次内存划分。
    
## 内存间交互操作
&emsp;&emsp;关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：

* lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。
*  unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
* read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
* load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
* use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时    将会执行这个操作。
* assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
* store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
* write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。

<br>
&emsp;&emsp;如果要把一个变量从主内存中复制到工作内存，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：

* 不允许read和load、store和write操作之一单独出现
* 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。
* 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。
* 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
* 一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现
* 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值
* 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
* 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。

## 原子性、可见性与有序性
* 原子性：由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，大致可以认为基本数据类型的访问读写是具备原子性的（long和double除外）。同步块--synchronized关键字之间的操作也具备原子性。

* 可见性：volatile可以保证多线程操作时变量的可见性。除此之外，synchronized和final也能实现可见性。

* 有序性：Java提供了volatile和synchronized两个关键字来保证线程之间操作的有序性。

## 先行发生原则
&emsp;&emsp;Java语言中有一个先行发生的原则（happens-before），它是判断数据是否存在竞争、线程是否安全的主要依据。下面是java内存模型中一些“天然的”先行发生关系：

* 程序顺序规则：在一个线程内，按照程序代码控制流程顺序，书写在前面的操作先行发生于后面的操作。
* 监视器锁规则：一个unlock操作先行发生于后面对同一个锁的lock操作。
* 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。
* 线程终止规则：线程中所有的操作都先行发生于对此线程的终止检测。
* 线程终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。
* volatile变量规则：对一个volatile变量的写，happens- before 于任意后续对这个变量的读。
* 传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。